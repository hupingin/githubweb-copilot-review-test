---
applyTo: '**/*.h, **/*.hpp, **/*.ipp, **/*.c, **/*.cpp, **/*.cc, **/*.cxx, **/*.cp, **/*.inl, **/*.tpp'
---
Provide code review guidelines for c and cpp.

## 头文件
1. 头文件要使用ifndef/define/endif预处理块。
2. 不允许在头文件中定义全局变量或静态变量（包括单个变量、数组、const的常量）。
3. 不允许在头文件中或者#include指令前使用using导入命名空间。
4. 不允许在头文件中定义具有链接的实体，包括全局变量、非内联函数等需要分配内存的实体。

## 宏
1. 宏定义需要使用大写来定义。
2. 宏定义参数必须用括号括起来,单一数值宏定义必须使用括号将宏值整体括起来。
3. 不允许宏变量参数包含具有副作用的表达式（如自增/自减）。

## 命名约定
1. 变量的命名需要符合以下a)~e)编码规范。
   a)作用域前缀（w-全局，n-静态，a-自动），例如 变量aubEepState中，首位小写英文字母a代表变量aubEepState是自动变量。
   b)全局变量必须使用模块名前缀（模块名_w）。
   c)符号前缀（u-无符号、s-有符号），例如 变量aubEepState中，第二位小写英文字母u代表变量aubEepState是无符号变量。
   d)类型前缀（c-INT8，s-INT16，l-INT32，p-指针，st-结构体）。
   e)数组前缀（a）。

## 变量、常量、表达式
1. 不允许有魔数的使用。
2. 不允许存在隐式类型转换。
3. 不允许有常量以#define方式定义，如#define MAX_FILES 20; 应为const unsigned MAX_FILES = 20.
4. 应该显式声明float类型。
5. 应该显式声明char类型为signed char或unsigned char，除非仅用来处理ASCII字符。
6. 不能使用int定义变量类型，可以使用short int或者long int这类明确变量长度的类型。
7. 变量使用前需要进行初始化，初始值设定要合理。
8. 标识符（函数名、变量名等）的总长度不要超过32个字符。
9. 局部变量不要与全局变量重名。
10. 是否有全局变量可以替换为局部变量。
11. 不要把局部变量(Auto变量)的地址赋值给全局或者静态指针。
12. 赋值操作中目的变量的值是否小于赋值表达式的值。
13. 是否使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串。
14. 静态变量不使用函数内的定义方式，尽可能采用页面内静态变量的定义方式。
15. 程序中不要使用二进制格式和八进制，只能使用十进制或者十六进制，为了阅读方便，可以以二进制格式描述作为注释。
16. 是否使用了不必要的float或者double类型，比如科学计算、数学库函数等高精度需求场景应定义为double, 仅需简单计算的低精度场景应定义为float类型。

## 运算、比较
1. 不同类型的变量不能混合计算，不能进行比较。
2. 当除数是变量或表达式时，必须验证变量或表达式值不为0.
3. 加法/减法处理时，需要考虑加法时的溢出、减法时的UnderFlow.
4. 不能使用 == 或 != 运算符来比较浮点数是否相等。
5. 不要使用unsigned类型的变量与0比较大小。
6. 不要使用无符号类型的变量进行运算结果比较。
7. 判断赋值的结果时，是否按需要加上了括号。
8. 在与宏、常量进行== != >= <=等比较运算时，应当将常量写在运算符左边，而变量写在运算符右边。

## 数组
1. 数组定义时，数组元素个数要使用宏定义而不是直接使用数值。正确示例：INT8U wucEventArray[MAX_IPOD_EVENT_SIZE]; 错误示例：INT8U wucEventArray[10].
2. 当使用变量作为数组下标时，必须保证变量取值小于数组元素个数。在引用数组前必须判断变量的范围。
3. 使用宏定义或者enum类型作为数组索引时，必须保证索引和数据元素个数的匹配。索引不能超过数据元素个数。
4. 使用memset、memcpy、memcmp进行数组操作时，必须保证size参数不越界。如果size参数是变量，则必须判断size变量的值不大于数组字节数。
5. 字符串是否有结束符'\0'。没有时，是否有长度限制处理。
6. 利用存储函数地址的数组进行函数调用前，必须判断函数表的索引小于函数表元素个数。
7. 获取整个数组长度时，使用sizeof而不是直接赋值。

## 指针
1. 使用指针操作时，向某个指针变量指向的地址中赋值的时候，要检查该变量指向的地址是否已经事先分配了空间，以及这个空间的长度是否能够容纳本次赋值操作。
2. 使用指针操作时，利用指针进行读取数据时，需要明确该指针是否已经指向已经分配的地址（变量或数组地址）。
3. 检查指针无效后，应该赋值为NULL.
4. 内存的分配和释放应该在同一模块中进行。
5. 用malloc或new申请内存后，应立即检查指针值是否为NULL.

## 函数
1. 每个函数体代码行数(注释、空行不是有效代码)都在80行以内。
2. 函数参数不多于6个。
3. 函数的参数和返回值禁止直接使用数字,需要利用宏(或enum类型)进行操作。
4. 在函数体的入口处，需要对参数的有效性(如类型，长度，格式和范围)进行必要的检查。
5. 在函数调用处，要对函数返回值的有效性进行必要的检查。
6. 函数返回值不允许赋给一个精度不够的变量。
7. 函数不能返回局部变量或临时变量的引用。
8. 返回值为指针的函数，不允许返回函数内部自动变量的地址。
9. 不能将正常值和错误标志混在一起返回，正常值应当用输出参数获得，而错误标志用return语句返回。
10. 对于有返回值的函数，不允许出现多个return语句，仅允许在函数末尾有一个return语句。多个分支可以采用返回值暂存临时变量。
11. 函数内外及嵌套代码块内外不允许有变量同名。
12. 应减少函数本身或函数间的递归调用，使用其它更好的实现方式。
13. 对于重复出现并完成同样单一功能的一段代码，是否用函数对其进行了封装。
14. 是否有可以被库函数替代的代码。
15. 是否存在更好的数据结构或更有效的算法。
16. 重复计算的值，能否通过计算一次并存储来实现。
17. 基类析构函数应该为公用且虚拟的，或者保护且非虚拟的。
18. 析构函数中是否遗漏了某些清除工作。
19. 请检查是否存在public成员函数返回指向成员变量的non-const引用或指针，并且不需要外部修改成员变量。
20. 应该通过const关键字保护函数的参数、返回值和函数体，来提高函数的健壮性。
21. 多个线程访问的数据，在所有线程中都用相同的锁锁定，或者用适当的原子操作处理。
22. 使用strcpy、sprintf、gets等不会自动检查目标缓冲区大小的传统函数时，应使用带保护的API，显式限制写入长度。使用strncpy或std::strncpy_s替代strcpy,使用snprintf替代sprintf,使用fgets或getline替代gets.

## 条件语句
1. 条件判断语句中不可以直接使用数字进行范围判断。
2. 条件判断语句中即使else分支没有处理，也必须写出else分支。
3. 条件判断语句的处理分支中无论语句多少，都使用大括号。
4. 同一层次分支不要多于5个。
5. 嵌套层次不要多于4层。

## 循环语句
1. switch case代码，每个case分支必须有一个break，必须要有Default语句。
2. 不要出现无符号数>=0，无符号数<0这样的循环结束条件。
3. 循环结束条件中不要出现赋值语句，例如aucFlag = 1.
4. 循环计数变量的取值范围要大于等于结束条件数值。例如，如果循环结束条件为Count < 256,那Count的类型必须使用INT16U或更长的数据类型，而不能使用INT8U.
5. 请检查是否存在因遗漏边界条件造成的未处理循环，比如： 遍历容器时未检查空状态（vector为空时begin() == end()）.
6. 循环语句与判断语句中尽量避免使用GOTO语句。
7. 在循环体中声明的变量，是否能放到循环之外。
8. 某些循环体内的计算，是否可以移到循环外。
9. 多个操作同一数据源的循环，能否合并成一个。
10. 循环体是否存在误差累积。

## 注释
1. 宏定义、函数、全局变量、常量、结构体定义的时候必须要写注释说明。
2. 函数体中，以处理为单位写注释，比如一组完成同一机能的处理为单位进行注释。
3. 出现的条件判断语句的位置需要进行注释，比如if…else, switch, while, for循环需要明确出所参照的条件。
4. 如果条件判断分支中处理内容较多，也要适当加入注释。
5. 代码注释只能使用/**/，不可以使用//.
6. 注释中不能使用中文汉字及其他可能出现乱码的文字。

## 文件
1. 使用std::tmpnam 或 mktemp生成临时文件名，而不是手动指定。
2. 同一指针变量关联新文件前，应先关闭当前文件。
3. 文件操作的流程是否正确，在使用前打开文件，使用后及时关闭文件。
4. 在操作文件时需要判断文件是否存在。

## 其它
1. 确保代码不会记录或打印任何敏感信息。
